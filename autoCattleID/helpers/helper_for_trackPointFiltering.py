'''
Author: Manu Ramesh

This module has filter functions to filter track-points.
'''

# import cv2, pickle, pdb, glob, os, 
import numpy as np, sys, pdb

sys.path.insert(0, '../../')
# sys.path.insert(0, '../autoCattlogger/helpers/')
# from autoCattlogger.helpers.helper_for_QR_and_inference import inferBitVector, findSameBitVecCows
from autoCattlogger.helpers.helper_for_infer import printAndLog
from collections import Counter
from tqdm import tqdm, trange

import logging
from shapely.geometry import Polygon
from multiprocessing import Pool, cpu_count
import multiprocessing
import pandas as pd
from scipy import stats #for computing the bit-wise statistical Mode of bit-vectors

import matplotlib.pyplot as plt

# from helper_for_morph import morph_cow_to_template




def getFilteredCattlog(tracksList, trackPtsFilterFn=None, **kwargs):
    '''
    Takes in the trackList that was used to generate the autoCattlog bitvectors.
    Filters the trackPoints in them as per specified criteria.
    Generates a new cattlog bitVector for each cow using the filtered list of trackpoints.

    :param tracksList: list of tracks from the training day - these are generated by the functions in the generateAutoCattlogsV2.py file.
    :param trackPtsFilterFn: function to filter the trackpoints in the training day tracks. This function should take in a list of trackpoints and return a filtered list of trackpoints. The function should also take in any additional arguments that are passed to it.
    :param **kwargs: additional arguments that are passed to the trackPtsFilterFn
    '''

    bitVecCattlogDict = {}

    for track in tracksList:
        
        trackPoints = track['trackPoints']
        
        if trackPtsFilterFn is not None:
            printAndLog(f"Filtering trackpoints to generate cattlog bitvector", logLevel='debug', printDebugInfoToScreen=False)
            trackPoints = trackPtsFilterFn(trackPoints, **kwargs)
        
        cowID = track['gt_label']
        
        #Method 1:
        # Final bit vector = bit-wise statistical mode of all bit vectors. => majority vote for white or black at each pixel block.

        bitVecList = [x['bitVecStr'] for x in trackPoints if x['bitVecStr'] != ''] #all trackPoints should have a bitVecStr now, but checking just in case no filtering is performed
        modeBitVec = stats.mode(bitVecList).mode #has .counts with the counts of each entry

        #if printDebugInfoToScreen: print(f"ModeBitVec = {modeBitVec}")

        finalBitVecStr = ''.join(modeBitVec[0].tolist()) #saving bit vector as a string of bits
        
        #track['autoCattBitVecStr'] = finalBitVecStr #need not save it in the track

        bitVecCattlogDict[f"{cowID}"] = {'blk16':finalBitVecStr}

    return bitVecCattlogDict


def getFilterFnFromName(trackPtsFilterFnName, justListAllAvailableFns=False):
    '''
    Given the name of the filter function, returns the corresponding function.
    '''

    filterFnDict = {
        'trackPtsFilter_bySizeOfRotatedBBoxes': trackPtsFilter_bySizeOfRotatedBBoxes,
        'trackPtsFilter_byProximityOfRBboxToFrameCenter': trackPtsFilter_byProximityOfRBboxToFrameCenter,
        'trackPtsFilter_closestImgToFrameCenter': trackPtsFilter_closestImgToFrameCenter,
        'trackPtsFilter_ablationStudy_trainingDay': trackPtsFilter_ablationStudy_trainingDay,
        'trackPtsFilter_ablationStudy_evalDay': trackPtsFilter_ablationStudy_evalDay
    }

    
    if justListAllAvailableFns:
        return list(filterFnDict.keys())
    

    if trackPtsFilterFnName in filterFnDict:
        return filterFnDict[trackPtsFilterFnName]
    elif trackPtsFilterFnName is None:
        return None
    else:
        raise ValueError(f"Invalid trackPtsFilterFnName: {trackPtsFilterFnName}. Must be one of {list(filterFnDict.keys())}")
    

#############################################################################################################################
############################# FILTER FUNCTIONS - TO FILTER TRACKPOINTS ######################################################

def trackPtsFilter_bySizeOfRotatedBBoxes(trackPoints, inclusionPercentage_top = 0.1):
    '''
    Filters trackpoints by size of rotated BBoxes.
    Returns top 'inclusionPercentage_top' percentage of trackpoints based on size of rotated BBoxes.
    '''

    printAndLog(f"Filtering trackPoints by size of rotated BBoxes. \ninclusionPercentage_top={inclusionPercentage_top}", logLevel='debug', printDebugInfoToScreen=False)

    #first select only those trackpoints that have a cow in them
    trackPoints = [trackPoint for trackPoint in trackPoints if trackPoint['bitVecStr'] != '']

    trackPoints = sorted(trackPoints, key=lambda x: Polygon(x['rotatedBBOX_locs']).area, reverse=True)
    trackPoints = trackPoints[:int(inclusionPercentage_top*len(trackPoints))]

    printAndLog(f"Number of trackPoints after filtering: {len(trackPoints)}", printDebugInfoToScreen=False)

    return trackPoints

def trackPtsFilter_byProximityOfRBboxToFrameCenter(trackPoints, inclusionPercentage_top = 0.2, frameW=1920, frameH=1080):
    '''
    Filters trackpoints by proximity of bounding box centroid to the frame center.

    The intuition is that if the cow is closer to the center of the frame, it is more likely to be detected in its correct pose.

    Returns top 'inclusionPercentage_top' percentage of trackpoints based on this criteria.
    '''

    # printAndLog(f"Filtering trackPoints by distance of (centroids of) rotated BBoxes to center of the frame", logLevel='debug', printDebugInfoToScreen=False) #temporarily disabling to reduce log size

    frameCenter = (frameW/2, frameH/2) #x,y  in this order
    
    #first select only those trackpoints that have a cow in them
    trackPoints = [trackPoint for trackPoint in trackPoints if trackPoint['bitVecStr'] != '']

    trackPoints = sorted(trackPoints, key=lambda x: np.linalg.norm(np.array(Polygon(x['rotatedBBOX_locs']).centroid) - np.array(frameCenter)), reverse=False) #must sort in increasing order of distance

    trackPoints = trackPoints[:int(inclusionPercentage_top*len(trackPoints))]

    # printAndLog(f"Number of trackPoints after filtering: {len(trackPoints)}", logLevel='debug', printDebugInfoToScreen=False) #temporarily disabling to reduce log size
    

    return trackPoints

def trackPtsFilter_closestImgToFrameCenter(trackPoints, frameW=1920, frameH=1080, **kwargs):
    '''
    Filters trackpoints by proximity of bounding box centroid to the frame center.

    The intuition is that if the cow is closer to the center of the frame, it is more likely to be detected in its correct pose.

    Returns top 1 trackpoint based on this criteria. The goal is to study how the system performs when trained on only a single instance.
    '''

    printAndLog(f"Filtering trackPoints by distance of (centroids of) rotated BBoxes to center of the frame. Choosing the single best (closest) image.", logLevel='debug', printDebugInfoToScreen=False)

    frameCenter = (frameW/2, frameH/2) #x,y  in this order
    
    #first select only those trackpoints that have a cow in them
    trackPoints = [trackPoint for trackPoint in trackPoints if trackPoint['bitVecStr'] != '']

    trackPoints = sorted(trackPoints, key=lambda x: np.linalg.norm(np.array(Polygon(x['rotatedBBOX_locs']).centroid) - np.array(frameCenter)), reverse=False) #must sort in increasing order of distance

    trackPoints = trackPoints[:1]

    printAndLog(f"Number of trackPoints after filtering: {len(trackPoints)}", logLevel='debug', printDebugInfoToScreen=False)
    # printAndLog(f"Number of trackPoints after filtering: {len(trackPoints)}", logLevel='info', printDebugInfoToScreen=False) #uncomment to see in the log if only one image was infact used

    return trackPoints


#def trackPtsFilter_ablationStudy_trainingDay(trackPoints, inclusionPercentage_top = 0.1, frameW=1920, frameH=1080):
def trackPtsFilter_ablationStudy_trainingDay(trackPoints, **kwargs):
    '''
    For ablation study.
    Filters out all Keypoint rectified track points. And then applies trackPtsFilter_byProximityOfRBboxToFrameCenter function.
    '''

    printAndLog(f"AblationStudy TrainingDayFilter: Filtering: Throwing away all keypoint corrected trackPoints.", logLevel='debug', printDebugInfoToScreen=False)
    trackPoints = [trackPoint for trackPoint in trackPoints if trackPoint['kpCorrectionMethodUsed'] is None] #this will also remove any trackpoints without a cow in them

    printAndLog(f"Number of trackPoints after first round of filtering: {len(trackPoints)}", logLevel='debug', printDebugInfoToScreen=False)

    #from autoCattlog.py 
    #in its current form, kpCorrectionMethodUsed will be '' if not all keypoints are correctly detected.
    # kpCorrectionMethodUsed will be None if no correction method was used but all keypoints are correctly detected.
    # kpCorrectionMethodUsed will be iter if iter mode was used to correct the keypoints, and all keypoints are correct after rectification.
    # kpCorrectionMethodUsed will be SBF if SBF mod was used to correct the keypoints, and all keypoints are correct after rectification.

    #trackPoints = trackPtsFilter_byProximityOfRBboxToFrameCenter(trackPoints, inclusionPercentage_top=inclusionPercentage_top, frameW=frameW, frameH=frameH)
    trackPoints = trackPtsFilter_byProximityOfRBboxToFrameCenter(trackPoints, **kwargs)

    return trackPoints



#def trackPtsFilter_ablationStudy_evalDay(trackPoints, inclusionPercentage_top = 0.1, frameW=1920, frameH=1080):
def trackPtsFilter_ablationStudy_evalDay(trackPoints, **kwargs):
    '''
    For ablation study.
    Filters out all Keypoint rectified track points. Applies no other filter.
    '''

    printAndLog(f"AblationStudy TrainingDayFilter: Filtering: Throwing away all keypoint corrected trackPoints.", logLevel='debug', printDebugInfoToScreen=False)
    trackPoints = [trackPoint for trackPoint in trackPoints if trackPoint['kpCorrectionMethodUsed'] is None] #this will also remove any trackpoints without a cow in them

    printAndLog(f"Number of trackPoints after filtering: {len(trackPoints)}", logLevel='debug', printDebugInfoToScreen=False)

    #from autoCattlog.py 
    #in its current form, kpCorrectionMethodUsed will be '' if not all keypoints are correctly detected.
    # kpCorrectionMethodUsed will be None if no correction method was used but all keypoints are correctly detected.
    # kpCorrectionMethodUsed will be iter if iter mode was used to correct the keypoints, and all keypoints are correct after rectification.
    # kpCorrectionMethodUsed will be SBF if SBF mod was used to correct the keypoints, and all keypoints are correct after rectification.


    return trackPoints



if __name__ == "__main__":

    filterFn = getFilterFnFromName('trackPtsFilter_bySizeOfRotatedBBoxes')
    print(f"Filter function: {filterFn}")